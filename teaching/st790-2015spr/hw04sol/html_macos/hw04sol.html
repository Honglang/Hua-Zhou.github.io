
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>hw04sol</title><meta name="generator" content="MATLAB 8.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-03-07"><meta name="DC.source" content="hw04sol.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">Q1: Prostate cancer data</a></li><li><a href="#3">Q2: L1 and L-inf regression</a></li><li><a href="#8">Q3: Quantile regression</a></li><li><a href="#9">Q4: Lasso penalized L1 regression</a></li><li><a href="#11">Q5: Dantzig selector</a></li><li><a href="#14">Q6: 1-norm SVM on the SA heart disease data</a></li></ul></div><pre class="codeinput"><span class="comment">% System information</span>
cpuinfo
</pre><pre class="codeoutput">
ans = 

             Name: 'Intel(R) Core(TM) i7-3720QM CPU @ 2.60GHz'
            Clock: '2600 MHz'
            Cache: '256 KB'
    NumProcessors: 4
           OSType: 'Mac OS/X'
        OSVersion: '10.9.5'

</pre><h2>Q1: Prostate cancer data<a name="2"></a></h2><pre class="codeinput">clear;
fid = fopen(<span class="string">'prostate.txt'</span>);
rawdata = textscan(fid, [repmat(<span class="string">'%f '</span>, 1, 10) <span class="string">'%s'</span>],<span class="keyword">...</span>
    <span class="string">'HeaderLines'</span>, 1, <span class="string">'CollectOutput'</span>, true);
fclose(fid);
<span class="comment">% row #, lcavol, lweight, age, lbph, svi, lcp, gleason, pgg45, lpsa, train</span>
trainidx = strcmp(rawdata{2}, <span class="string">'T'</span>);
rawdata = rawdata{1, 1};
X = [ones(size(rawdata, 1), 1) rawdata(:, 2:9)];
y = rawdata(:, 10);
<span class="comment">% standardize predictors</span>
X(:, 2:end) = bsxfun(@minus, X(:, 2:end), mean(X(:, 2:end), 1));   <span class="comment">% centering</span>
X(:, 2:end) = bsxfun(@rdivide, X(:, 2:end), std(X(:, 2:end)));

<span class="comment">% train/test split</span>
Xtr = X(trainidx, :);
ytr = y(trainidx);
Xte = X(~trainidx, :);
yte = y(~trainidx);

<span class="comment">% L2 regression (least squares) on original training data</span>
bhat_l2_orig = Xtr \ ytr;
res_l2_orig = ytr - Xtr * bhat_l2_orig;

figure
set(gca, <span class="string">'FontSize'</span>, 15);
plot(1:length(ytr), res_l2_orig, <span class="string">'o'</span>);
xlabel(<span class="string">'observation number'</span>);
ylabel(<span class="string">'residuals'</span>);
title(<span class="string">'L_2 reg. on original training data'</span>)
</pre><img vspace="5" hspace="5" src="hw04sol_01.png" alt=""> <h2>Q2: L1 and L-inf regression<a name="3"></a></h2><pre class="codeinput"><span class="comment">% Corrupt ytr by one outliers</span>
ytr(end) = ytr(end) * 10;  <span class="comment">% add one outliers</span>

<span class="comment">% L2 regression (least squares) on corrupted training data</span>
bhat_l2 = Xtr \ ytr;
res_l2 = ytr - Xtr * bhat_l2;

figure
set(gca, <span class="string">'FontSize'</span>, 15);
plot(1:length(ytr), ytr - Xtr * bhat_l2, <span class="string">'o'</span>);
xlabel(<span class="string">'observation number'</span>);
ylabel(<span class="string">'residuals'</span>);
title(<span class="string">'L_2 reg. on perturbed data'</span>)
</pre><img vspace="5" hspace="5" src="hw04sol_02.png" alt=""> <p>L1 regression (LAD) on corrupted training data</p><pre class="codeinput">tic;
bhat_l1 = lpreg(Xtr, ytr, 1);
toc;
res_l1 = ytr - Xtr * bhat_l1;

figure
set(gca, <span class="string">'FontSize'</span>, 15);
plot(1:length(ytr), res_l1, <span class="string">'o'</span>);
xlabel(<span class="string">'observation number'</span>);
ylabel(<span class="string">'residuals'</span>);
title(<span class="string">'L_1 reg. on perturbed training data'</span>)
</pre><pre class="codeoutput">Elapsed time is 0.011304 seconds.
</pre><img vspace="5" hspace="5" src="hw04sol_03.png" alt=""> <p>Linf regression on corrupted training data</p><pre class="codeinput">tic;
bhat_linf = lpreg(Xtr, ytr, inf);
toc;
res_linf = ytr - Xtr * bhat_linf;

figure
set(gca, <span class="string">'FontSize'</span>, 15);
plot(1:length(ytr), res_linf, <span class="string">'o'</span>);
xlabel(<span class="string">'observation number'</span>);
ylabel(<span class="string">'residuals'</span>);
title(<span class="string">'L-inf reg. on perturbed data'</span>)
</pre><pre class="codeoutput">Elapsed time is 0.004232 seconds.
</pre><img vspace="5" hspace="5" src="hw04sol_04.png" alt=""> <p>Summarize results</p><pre class="codeinput">table([bhat_l2_orig; norm(res_l2_orig, 1); <span class="keyword">...</span>
  norm(res_l2_orig, 2); norm(res_l2_orig, Inf);
  norm(yte - Xte * bhat_l2_orig)^2 / length(yte)], <span class="keyword">...</span>
  [bhat_l1; norm(res_l1, 1); norm(res_l1, 2); <span class="keyword">...</span>
  norm(res_l1, Inf); norm(yte - Xte * bhat_l1)^2 / length(yte)], <span class="keyword">...</span>
  [bhat_l2; norm(res_l2, 1); norm(res_l2, 2); <span class="keyword">...</span>
  norm(res_l2, Inf); norm(yte - Xte * bhat_l2)^2 / length(yte)], <span class="keyword">...</span>
  [bhat_linf; norm(res_linf, 1); norm(res_linf, 2);
  norm(res_linf, Inf); norm(yte - Xte * bhat_linf)^2 / length(yte)], <span class="keyword">...</span>
  <span class="string">'VariableNames'</span>, {<span class="string">'L2_Reg_True'</span>, <span class="string">'L1_Reg'</span>, <span class="string">'L2_Reg'</span>, <span class="string">'Linf_Reg'</span>}, <span class="keyword">...</span>
  <span class="string">'RowNames'</span>, {<span class="string">'intercpt'</span>, <span class="string">'lcavol'</span>, <span class="string">'lweight'</span>, <span class="string">'age'</span>, <span class="string">'lbph'</span>, <span class="string">'svi'</span>, <span class="keyword">...</span>
  <span class="string">'lcp'</span>, <span class="string">'gleason'</span>, <span class="string">'pgg45'</span>, <span class="string">'L1 loss'</span>, <span class="string">'L2 loss'</span>, <span class="string">'Linf loss'</span>, <span class="string">'Test error'</span>})
</pre><pre class="codeoutput">
ans = 

                  L2_Reg_True     L1_Reg      L2_Reg     Linf_Reg 
                  ___________    ________    ________    _________

    intercpt         2.4649        2.4431      2.9617       5.0524
    lcavol          0.67953       0.58389      1.0703       9.1984
    lweight         0.26305       0.27091    -0.38856    -0.076956
    age            -0.14146      -0.23109     -0.1277      -1.0545
    lbph            0.21015       0.30471      1.4992       5.5695
    svi              0.3052       0.34266      1.6154       2.6952
    lcp            -0.28849       -0.1244     -1.1161      -3.1856
    gleason       -0.021305       0.12734     -1.9826      -5.8453
    pgg45           0.26696       0.10872      2.7956       7.5934
    L1 loss          33.407        81.328      160.48        656.8
    L2 loss          5.4246        50.845      46.774       95.368
    Linf loss        1.6487        50.551      42.614       18.664
    Test error      0.52127       0.49466      6.5098       82.678

</pre><p>This is my function for fitting L1, L2, or L-inf regressions</p><pre class="codeinput">type <span class="string">lpreg</span>
</pre><pre class="codeoutput">
function [bhat] = lpreg(X, y, p, varargin)
% LPREG Lp regression for p = 1, 2, or inf
%   [BHAT] = LPREG(X, y, p) finds regression coeffcients bhat that minimize
%     norm(y - X * bhat, p).
%
% INPUT:
%   X - n-by-p design matrix
%   y - n-by-1 response vector
%   p - 1|2 (default)|inf
%
% OPTIONAL NAME-VALUE PAIRS:
%
% OUTPUT:
%   bhat - p-by-1 regression coefficents
%
% Example
%
% References
%

% Copyright 2015 North Carolina State University
% Hua Zhou (hua_zhou@ncsu.edu)

% input parsing rule
[n, q] = size(X);
argin = inputParser;
argin.addRequired('X', @isnumeric);
argin.addRequired('y', @(x) isnumeric(x) &amp;&amp; length(y)==n);
argin.addRequired('p', @(x) isnumeric(x) &amp;&amp; x&gt;=0);

% parse inputs
argin.parse(X, y, p, varargin{:});

% L1 (LAD) regression
if p == 1
  
  % use QUROBI solver if possible
  gmodel.obj = [ones(2*n, 1); zeros(q, 1)];
  gmodel.A = [speye(n) -speye(n) X];
  gmodel.sense = '=';
  gmodel.rhs = y;
  gmodel.lb = [zeros(2*n, 1); -inf(q, 1)];
  gparam.OutputFlag = 0;
  gresult = gurobi(gmodel, gparam);
  bhat = gresult.x(2*n+1:end);

% L2 (least squares) regression
elseif p == 2
  
  bhat = X \ y;
  
% Linfty regression
elseif isinf(p)
  
%   cvx_begin
%     variable bhat(q)
%     minimize norm(y - X * bhat, inf)
%   cvx_end

  % use QUROBI solver if possible
  gmodel.obj = [1; zeros(q, 1)];
  gmodel.A = sparse([-ones(n, 1) -X; -ones(n, 1) X]);
  gmodel.sense = repmat('&lt;', 2 * n, 1);
  gmodel.rhs = [-y; y];
  gmodel.lb = [zeros, -inf(1, q)];
  gparam.OutputFlag = 0;
  gresult = gurobi(gmodel, gparam);
  bhat = gresult.x(2:end);
  
end

end
</pre><h2>Q3: Quantile regression<a name="8"></a></h2><pre class="codeinput"><span class="comment">% Corrupt ytr by one outliers</span>
ytr = y(trainidx);
ytr(end) = ytr(end) * 10;  <span class="comment">% add one outliers</span>

<span class="comment">% solve quantile regression at tau = 0.25, 0.5, 0.75</span>
taulist = [0.25, 0.5, 0.75];
bhat = zeros(size(Xtr, 2), length(taulist));
res = zeros(size(Xtr, 1), length(taulist));
err = zeros(1, length(taulist));
tic;
<span class="keyword">for</span> i = 1:length(taulist)
  tau = taulist(i);
  bhat(:, i) = quantreg(Xtr, ytr, tau);
  err(i) = norm(yte - Xte * bhat(:, i))^2 / length(yte);
  res(:, i) = ytr - Xtr * bhat(:, i);
<span class="keyword">end</span>
toc;

<span class="comment">% Summarize results</span>
table([bhat_l2_orig; norm(res_l2_orig, 1); <span class="keyword">...</span>
  norm(res_l2_orig, 2); norm(res_l2_orig, Inf);
  norm(yte - Xte * bhat_l2_orig)^2/length(yte)], <span class="keyword">...</span>
  [bhat(:, 1); norm(res(:, 1), 1); norm(res(:, 1), 2); <span class="keyword">...</span>
  norm(res(:, 1), Inf); err(1)], <span class="keyword">...</span>
  [bhat(:, 2); norm(res(:, 2), 1); norm(res(:, 2), 2); <span class="keyword">...</span>
  norm(res(:, 2), Inf); err(2)], <span class="keyword">...</span>
  [bhat(:, 3); norm(res(:, 3), 1); norm(res(:, 3), 2);
  norm(res(:, 3), Inf); err(3)], <span class="keyword">...</span>
  <span class="string">'VariableNames'</span>, {<span class="string">'L2_Reg_True'</span>, <span class="string">'Q1'</span>, <span class="string">'Median'</span>, <span class="string">'Q3'</span>}, <span class="keyword">...</span>
  <span class="string">'RowNames'</span>, {<span class="string">'intercpt'</span>, <span class="string">'lcavol'</span>, <span class="string">'lweight'</span>, <span class="string">'age'</span>, <span class="string">'lbph'</span>, <span class="string">'svi'</span>, <span class="keyword">...</span>
  <span class="string">'lcp'</span>, <span class="string">'gleason'</span>, <span class="string">'pgg45'</span>, <span class="string">'L1 loss'</span>, <span class="string">'L2 loss'</span>, <span class="string">'Linf loss'</span>, <span class="string">'Test error'</span>})
</pre><pre class="codeoutput">Elapsed time is 0.007787 seconds.

ans = 

                  L2_Reg_True       Q1        Median        Q3    
                  ___________    ________    ________    _________

    intercpt         2.4649        2.1425      2.4431       3.0156
    lcavol          0.67953       0.75374     0.58389      0.73336
    lweight         0.26305       0.28532     0.27091     0.047868
    age            -0.14146      -0.17962    -0.23109    -0.020262
    lbph            0.21015       0.28391     0.30471      0.20085
    svi              0.3052       0.36623     0.34266      0.27373
    lcp            -0.28849      -0.28481     -0.1244     -0.20381
    gleason       -0.021305      0.086891     0.12734     -0.17075
    pgg45           0.26696       0.25195     0.10872      0.24553
    L1 loss          33.407        86.576      81.328       95.096
    L2 loss          5.4246        50.879      50.845        50.45
    Linf loss        1.6487        50.505      50.551       49.909
    Test error      0.52127       0.65304     0.49466      0.73737

</pre><h2>Q4: Lasso penalized L1 regression<a name="9"></a></h2><pre class="codeinput"><span class="comment">% restore to original y values</span>
ytr = y(trainidx);
</pre><p>Solve lasso penalized l1 over a grid</p><pre class="codeinput">lambdalist = 0:45;
bhat_path = zeros(size(Xtr, 2), length(lambdalist));
err_path = zeros(1, length(lambdalist));
tic;
<span class="keyword">for</span> i = 1:length(lambdalist)
  lambda = lambdalist(i);
  <span class="comment">% transform to an L1 regression problem</span>
  Xtmp = lambda * eye(size(Xtr, 2));
  Xtmp(1, :) = []; <span class="comment">% not penalize the intercept</span>
  Xtmp = [Xtr; Xtmp]; <span class="comment">%#ok&lt;AGROW&gt;</span>
  ytmp = [ytr; zeros(size(Xtr, 2) - 1, 1)];
  bhat_path(:, i) = lpreg(Xtmp, ytmp, 1);
  err_path(i) = norm(yte - Xte * bhat_path(:, i))^2/length(yte);
<span class="keyword">end</span>
toc;

<span class="comment">% plot solution path</span>
figure;
set(gca, <span class="string">'FontSize'</span>, 15);
plot(lambdalist, bhat_path(2:end, :));
xlabel(<span class="string">'\lambda'</span>);
title(<span class="string">'Lasso penalized L1 regression'</span>);
predname = {<span class="string">'lcavol'</span>, <span class="string">'lweight'</span>, <span class="string">'age'</span>, <span class="string">'lbph'</span>, <span class="string">'svi'</span>, <span class="keyword">...</span>
  <span class="string">'lcp'</span>, <span class="string">'gleason'</span>, <span class="string">'pgg45'</span>};
<span class="keyword">for</span> i = 1:length(predname)
  text(-3, bhat_path(i + 1, 1), predname{i}, <span class="string">'HorizontalAlignment'</span>,<span class="string">'right'</span>);
<span class="keyword">end</span>

<span class="comment">% plot testing error</span>
figure;
set(gca, <span class="string">'FontSize'</span>, 15);
plot(lambdalist, err_path);
xlabel(<span class="string">'\lambda'</span>);
ylabel(<span class="string">'test error'</span>);
title(<span class="string">'Lasso penalized L1 reg.'</span>);
</pre><pre class="codeoutput">Elapsed time is 0.149211 seconds.
</pre><img vspace="5" hspace="5" src="hw04sol_05.png" alt=""> <img vspace="5" hspace="5" src="hw04sol_06.png" alt=""> <h2>Q5: Dantzig selector<a name="11"></a></h2><pre class="codeinput"><span class="comment">% restore original y values</span>
ytr = y(trainidx);
</pre><p>Solve Dantzig selector over a grid</p><pre class="codeinput">lambdalist = 0:0.1:2.5;
bhat_path = zeros(size(Xtr, 2), length(lambdalist));
err_path = zeros(1, length(lambdalist));
tic;
<span class="keyword">for</span> i = 1:length(lambdalist)
  lambda = lambdalist(i);
  bhat_path(:, i) = dantzig(Xtr, ytr, lambda);
  err_path(i) = norm(yte - Xte * bhat_path(:, i))^2 / length(yte);
<span class="keyword">end</span>
toc;

<span class="comment">% plot solution path</span>
figure;
set(gca, <span class="string">'FontSize'</span>, 15);
plot(lambdalist, bhat_path(2:end, :));
xlabel(<span class="string">'\lambda'</span>);
title(<span class="string">'Dantzig selector'</span>);
predname = {<span class="string">'lcavol'</span>, <span class="string">'lweight'</span>, <span class="string">'age'</span>, <span class="string">'lbph'</span>, <span class="string">'svi'</span>, <span class="keyword">...</span>
  <span class="string">'lcp'</span>, <span class="string">'gleason'</span>, <span class="string">'pgg45'</span>};
<span class="keyword">for</span> i = 1:length(predname)
  text(lambdalist(end)+0.03, bhat_path(i + 1, end), predname{i}, <span class="keyword">...</span>
    <span class="string">'HorizontalAlignment'</span>,<span class="string">'left'</span>);
<span class="keyword">end</span>

<span class="comment">% plot testing error</span>
figure;
set(gca, <span class="string">'FontSize'</span>, 15);
plot(lambdalist, err_path);
xlabel(<span class="string">'\lambda'</span>);
ylabel(<span class="string">'prediction error'</span>);
title(<span class="string">'Dantzig selector'</span>);
</pre><pre class="codeoutput">Elapsed time is 0.045072 seconds.
</pre><img vspace="5" hspace="5" src="hw04sol_07.png" alt=""> <img vspace="5" hspace="5" src="hw04sol_08.png" alt=""> <p>This is my function for solving Dantzig selector</p><pre class="codeinput">type <span class="string">dantzig</span>
</pre><pre class="codeoutput">
function [bhat] = dantzig(X, y, lambda, varargin)
% DANTZIG Dantzig selector
%   [BHAT] = DANTZIG(X, y, lambda) finds regression coeffcients bhat that 
%     minimize norm(y - X * bhat, inf) subject to L1 constraint 
%     norm(bhat(2:end), 1) &lt;= lambda.
%
% INPUT:
%   X - n-by-p design matrix, first column should be intercept
%   y - n-by-1 response vector
%   lambda - nonnegative scalar
%
% OPTIONAL NAME-VALUE PAIRS:
%
% OUTPUT:
%   bhat - p-by-1 regression coefficents
%
% Example
%
% References
%

% Copyright 2015 North Carolina State University
% Hua Zhou (hua_zhou@ncsu.edu)

% input parsing rule
[n, p] = size(X);
argin = inputParser;
argin.addRequired('X', @isnumeric);
argin.addRequired('y', @(x) isnumeric(x) &amp;&amp; length(y)==n);
argin.addRequired('lambda', @(x) isnumeric(x) &amp;&amp; x&gt;=0);

% parse inputs
argin.parse(X, y, lambda, varargin{:});

% precompute inner products
xtx = X' * X;
xty = X' * y;
% model parameters: t, b+, b-
gmodel.obj = [1; zeros(2 * p, 1)];
% magnitude of p gradients should be less than t
gmodel.A = sparse([-ones(p, 1) -xtx xtx; -ones(p, 1) xtx -xtx]);
gmodel.sense = repmat('&lt;', 2 * p, 1);
gmodel.rhs = [-xty; xty];
% L1 constraint
gmodel.A = [gmodel.A; 0, 0, ones(1, p - 1), 0, ones(1, p - 1)];
gmodel.sense = [gmodel.sense; '&lt;'];
gmodel.rhs = [gmodel.rhs; lambda];
% optimize!
gparam.OutputFlag = 0;
gresult = gurobi(gmodel, gparam);
bhat = gresult.x(2:p + 1) - gresult.x(p + 2:end);

end
</pre><h2>Q6: 1-norm SVM on the SA heart disease data<a name="14"></a></h2><p>Read in data</p><pre class="codeinput">clear;
fid = fopen(<span class="string">'saheart.txt'</span>);
rawdata = textscan(fid, [repmat(<span class="string">'%f '</span>, 1, 5) <span class="string">'%s '</span> repmat(<span class="string">'%f '</span>, 1, 6)],<span class="keyword">...</span>
    <span class="string">'HeaderLines'</span>, 1, <span class="string">'CollectOutput'</span>, true);
fclose(fid);
rawdata = [rawdata{1,1} cellfun(@(s) strcmp(s,<span class="string">'Present'</span>),rawdata{1, 2}), <span class="keyword">...</span>
    rawdata{1, 3}];

<span class="comment">% sbp, tobacco, ldl, famhist, obesity, alcohol, age</span>
X = rawdata(:,[2 3 4 6 8 9 10]);
X = bsxfun(@minus, X, mean(X, 1));   <span class="comment">% centering</span>
X = bsxfun(@rdivide, X, std(X));    <span class="comment">% standardize</span>
X = [ones(size(X,1), 1), X];
y = rawdata(:, end - 1);
trainidx = logical(rawdata(:, end));

<span class="comment">% train/test split</span>
Xtr = X(trainidx, :);
ytr = y(trainidx);
Xte = X(~trainidx, :);
yte = y(~trainidx);

<span class="comment">% fit logistic reg. and make sure the results match that in ESLII p126 Fig 4.13</span>
b0 = glmfit(Xtr, ytr, <span class="string">'binomial'</span>,<span class="string">'constant'</span>,<span class="string">'off'</span>);
display(b0);

<span class="comment">% change 0/1-valued y to -1/1-valued class labels</span>
ctr = 2 * ytr - 1;
cte = 2 * yte - 1;
</pre><pre class="codeoutput">
b0 =

   -0.8640
    0.2767
    0.3088
    0.3690
    0.5044
   -0.1116
    0.0892
    0.6316

</pre><p>Solve 1-norm svm over a grid</p><pre class="codeinput">lambdalist = 0:0.1:2.5;
bhat_path = zeros(size(Xtr, 2), length(lambdalist));
err_path = zeros(1, length(lambdalist));
tic;
<span class="keyword">for</span> i = 1:length(lambdalist)
  lambda = lambdalist(i);
  bhat_path(:, i) = svml1(Xtr, ctr, lambda);
  err_path(i) = nnz(cte ~= sign(Xte * bhat_path(:, i))) / length(cte);
<span class="keyword">end</span>
toc;

<span class="comment">% plot solution path</span>
figure;
set(gca, <span class="string">'FontSize'</span>, 15);
plot(lambdalist, bhat_path(2:end, :));
xlabel(<span class="string">'\lambda'</span>);
title(<span class="string">'1-norm SVM'</span>);
predname = {<span class="string">'sbp'</span>, <span class="string">'tobacco'</span>, <span class="string">'ldl'</span>, <span class="string">'famhist'</span>, <span class="string">'obesity'</span>, <span class="string">'alcohol'</span>, <span class="string">'age'</span>};
<span class="keyword">for</span> i = 1:length(predname)
  text(lambdalist(end)+0.03, bhat_path(i + 1, end), predname{i}, <span class="keyword">...</span>
    <span class="string">'HorizontalAlignment'</span>,<span class="string">'left'</span>);
<span class="keyword">end</span>

<span class="comment">% plot testing error</span>
figure;
set(gca, <span class="string">'FontSize'</span>, 15);
plot(lambdalist, err_path);
xlabel(<span class="string">'\lambda'</span>);
ylabel(<span class="string">'misclassification rate'</span>);
title(<span class="string">'1-norm SVM'</span>);
</pre><pre class="codeoutput">Elapsed time is 0.384947 seconds.
</pre><img vspace="5" hspace="5" src="hw04sol_09.png" alt=""> <img vspace="5" hspace="5" src="hw04sol_10.png" alt=""> <p>This is my function for fitting 1-norm svm</p><pre class="codeinput">type <span class="string">svml1</span>
</pre><pre class="codeoutput">
function [bhat] = svml1(X, y, lambda, varargin)
% SVML1 1-norm support vector machine
%   [BHAT] = SVML1(X, y, lambda) finds regression coeffcients bhat that minimize
%     sum_pos(1 - y .* (X * bhat)) subject to the L1 constraint
%     norm(bhat(2:end), 1) &lt;= lambda
%
% INPUT:
%   X - n-by-p predictor matrix, first column should be intercept
%   y - n-by-1 class labels taking values -1 or 1
%   lambda - nonnegative scalar
%
% OPTIONAL NAME-VALUE PAIRS:
%
% OUTPUT:
%   bhat - p-by-1 regression coefficents
%
% Example
%
% References
%

% Copyright 2015 North Carolina State University
% Hua Zhou (hua_zhou@ncsu.edu)

% input parsing rule
[n, p] = size(X);
argin = inputParser;
argin.addRequired('X', @isnumeric);
argin.addRequired('y', @(x) isnumeric(x) &amp;&amp; length(y)==n);
argin.addRequired('lambda', @(x) isnumeric(x) &amp;&amp; x&gt;=0);

% parse inputs
argin.parse(X, y, lambda, varargin{:});

% pre-compute y.*X
yx = bsxfun(@times, y, X);

% % cvx 
% cvx_begin
%   variable bhat(p)
%   minimize sum(pos(1 - yx * bhat))
%   subject to
%     sum(abs(bhat(2:end))) &lt;= lambda
% cvx_end

% parameters are r+, r-, b+, b-
gmodel.obj = [ones(n, 1); zeros(n + 2 * p, 1)];
% equality constraint: r+ - r- = 1 - y .* (X * (b+ - b-))
gmodel.A = [speye(n), -speye(n), yx, -yx];
gmodel.sense = repmat('=', n, 1);
gmodel.rhs = ones(n, 1);
% L1 constraint
gmodel.A = [gmodel.A; ...
  zeros(1, 2 * n), 0, ones(1, p - 1), 0, ones(1, p - 1)];
gmodel.sense = [gmodel.sense; '&lt;'];
gmodel.rhs = [gmodel.rhs; lambda];
% lower bound: r+ &gt;= 0, r- &gt;= 0, b+ &gt;= 0, b- &gt;= 0
gmodel.lb = zeros(2 * (p + n), 1);
gparam.OutputFlag = 0;
gresult = gurobi(gmodel, gparam);
bhat = gresult.x(2 * n + 1: 2 * n + p) - gresult.x(2 * n + p + 1:end);

end
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014a</a><br></p></div><!--
##### SOURCE BEGIN #####
% System information
cpuinfo

%% Q1: Prostate cancer data

clear;
fid = fopen('prostate.txt');
rawdata = textscan(fid, [repmat('%f ', 1, 10) '%s'],...
    'HeaderLines', 1, 'CollectOutput', true);
fclose(fid);
% row #, lcavol, lweight, age, lbph, svi, lcp, gleason, pgg45, lpsa, train
trainidx = strcmp(rawdata{2}, 'T');
rawdata = rawdata{1, 1};
X = [ones(size(rawdata, 1), 1) rawdata(:, 2:9)];
y = rawdata(:, 10);
% standardize predictors
X(:, 2:end) = bsxfun(@minus, X(:, 2:end), mean(X(:, 2:end), 1));   % centering
X(:, 2:end) = bsxfun(@rdivide, X(:, 2:end), std(X(:, 2:end)));

% train/test split
Xtr = X(trainidx, :);
ytr = y(trainidx);
Xte = X(~trainidx, :);
yte = y(~trainidx);

% L2 regression (least squares) on original training data
bhat_l2_orig = Xtr \ ytr;
res_l2_orig = ytr - Xtr * bhat_l2_orig;

figure
set(gca, 'FontSize', 15);
plot(1:length(ytr), res_l2_orig, 'o');
xlabel('observation number');
ylabel('residuals');
title('L_2 reg. on original training data')

%% Q2: L1 and L-inf regression

% Corrupt ytr by one outliers
ytr(end) = ytr(end) * 10;  % add one outliers

% L2 regression (least squares) on corrupted training data
bhat_l2 = Xtr \ ytr;
res_l2 = ytr - Xtr * bhat_l2;

figure
set(gca, 'FontSize', 15);
plot(1:length(ytr), ytr - Xtr * bhat_l2, 'o');
xlabel('observation number');
ylabel('residuals');
title('L_2 reg. on perturbed data')

%%
% L1 regression (LAD) on corrupted training data
tic;
bhat_l1 = lpreg(Xtr, ytr, 1);
toc;
res_l1 = ytr - Xtr * bhat_l1;

figure
set(gca, 'FontSize', 15);
plot(1:length(ytr), res_l1, 'o');
xlabel('observation number');
ylabel('residuals');
title('L_1 reg. on perturbed training data')

%%
% Linf regression on corrupted training data
tic;
bhat_linf = lpreg(Xtr, ytr, inf);
toc;
res_linf = ytr - Xtr * bhat_linf;

figure
set(gca, 'FontSize', 15);
plot(1:length(ytr), res_linf, 'o');
xlabel('observation number');
ylabel('residuals');
title('L-inf reg. on perturbed data')

%%
% Summarize results
table([bhat_l2_orig; norm(res_l2_orig, 1); ...
  norm(res_l2_orig, 2); norm(res_l2_orig, Inf); 
  norm(yte - Xte * bhat_l2_orig)^2 / length(yte)], ...
  [bhat_l1; norm(res_l1, 1); norm(res_l1, 2); ...
  norm(res_l1, Inf); norm(yte - Xte * bhat_l1)^2 / length(yte)], ...
  [bhat_l2; norm(res_l2, 1); norm(res_l2, 2); ...
  norm(res_l2, Inf); norm(yte - Xte * bhat_l2)^2 / length(yte)], ...
  [bhat_linf; norm(res_linf, 1); norm(res_linf, 2); 
  norm(res_linf, Inf); norm(yte - Xte * bhat_linf)^2 / length(yte)], ...
  'VariableNames', {'L2_Reg_True', 'L1_Reg', 'L2_Reg', 'Linf_Reg'}, ...
  'RowNames', {'intercpt', 'lcavol', 'lweight', 'age', 'lbph', 'svi', ...
  'lcp', 'gleason', 'pgg45', 'L1 loss', 'L2 loss', 'Linf loss', 'Test error'})

%%
% This is my function for fitting L1, L2, or L-inf regressions
type lpreg

%% Q3: Quantile regression

% Corrupt ytr by one outliers
ytr = y(trainidx);
ytr(end) = ytr(end) * 10;  % add one outliers

% solve quantile regression at tau = 0.25, 0.5, 0.75
taulist = [0.25, 0.5, 0.75];
bhat = zeros(size(Xtr, 2), length(taulist));
res = zeros(size(Xtr, 1), length(taulist));
err = zeros(1, length(taulist));
tic;
for i = 1:length(taulist)
  tau = taulist(i);
  bhat(:, i) = quantreg(Xtr, ytr, tau);
  err(i) = norm(yte - Xte * bhat(:, i))^2 / length(yte);
  res(:, i) = ytr - Xtr * bhat(:, i);
end
toc;

% Summarize results
table([bhat_l2_orig; norm(res_l2_orig, 1); ...
  norm(res_l2_orig, 2); norm(res_l2_orig, Inf); 
  norm(yte - Xte * bhat_l2_orig)^2/length(yte)], ...
  [bhat(:, 1); norm(res(:, 1), 1); norm(res(:, 1), 2); ...
  norm(res(:, 1), Inf); err(1)], ...
  [bhat(:, 2); norm(res(:, 2), 1); norm(res(:, 2), 2); ...
  norm(res(:, 2), Inf); err(2)], ...
  [bhat(:, 3); norm(res(:, 3), 1); norm(res(:, 3), 2); 
  norm(res(:, 3), Inf); err(3)], ...
  'VariableNames', {'L2_Reg_True', 'Q1', 'Median', 'Q3'}, ...
  'RowNames', {'intercpt', 'lcavol', 'lweight', 'age', 'lbph', 'svi', ...
  'lcp', 'gleason', 'pgg45', 'L1 loss', 'L2 loss', 'Linf loss', 'Test error'})

%% Q4: Lasso penalized L1 regression

% restore to original y values
ytr = y(trainidx);

%%
% Solve lasso penalized l1 over a grid
lambdalist = 0:45;
bhat_path = zeros(size(Xtr, 2), length(lambdalist));
err_path = zeros(1, length(lambdalist));
tic;
for i = 1:length(lambdalist)
  lambda = lambdalist(i);
  % transform to an L1 regression problem
  Xtmp = lambda * eye(size(Xtr, 2));
  Xtmp(1, :) = []; % not penalize the intercept
  Xtmp = [Xtr; Xtmp]; %#ok<AGROW>
  ytmp = [ytr; zeros(size(Xtr, 2) - 1, 1)];
  bhat_path(:, i) = lpreg(Xtmp, ytmp, 1);
  err_path(i) = norm(yte - Xte * bhat_path(:, i))^2/length(yte);
end
toc;

% plot solution path
figure;
set(gca, 'FontSize', 15);
plot(lambdalist, bhat_path(2:end, :));
xlabel('\lambda');
title('Lasso penalized L1 regression');
predname = {'lcavol', 'lweight', 'age', 'lbph', 'svi', ...
  'lcp', 'gleason', 'pgg45'};
for i = 1:length(predname)
  text(-3, bhat_path(i + 1, 1), predname{i}, 'HorizontalAlignment','right');
end

% plot testing error
figure;
set(gca, 'FontSize', 15);
plot(lambdalist, err_path);
xlabel('\lambda');
ylabel('test error');
title('Lasso penalized L1 reg.');

%% Q5: Dantzig selector

% restore original y values
ytr = y(trainidx);

%%
% Solve Dantzig selector over a grid
lambdalist = 0:0.1:2.5;
bhat_path = zeros(size(Xtr, 2), length(lambdalist));
err_path = zeros(1, length(lambdalist));
tic;
for i = 1:length(lambdalist)
  lambda = lambdalist(i);
  bhat_path(:, i) = dantzig(Xtr, ytr, lambda);
  err_path(i) = norm(yte - Xte * bhat_path(:, i))^2 / length(yte);
end
toc;

% plot solution path
figure;
set(gca, 'FontSize', 15);
plot(lambdalist, bhat_path(2:end, :));
xlabel('\lambda');
title('Dantzig selector');
predname = {'lcavol', 'lweight', 'age', 'lbph', 'svi', ...
  'lcp', 'gleason', 'pgg45'};
for i = 1:length(predname)
  text(lambdalist(end)+0.03, bhat_path(i + 1, end), predname{i}, ...
    'HorizontalAlignment','left');
end

% plot testing error
figure;
set(gca, 'FontSize', 15);
plot(lambdalist, err_path);
xlabel('\lambda');
ylabel('prediction error');
title('Dantzig selector');

%%
% This is my function for solving Dantzig selector
type dantzig

%% Q6: 1-norm SVM on the SA heart disease data

%%
% Read in data
clear;
fid = fopen('saheart.txt');
rawdata = textscan(fid, [repmat('%f ', 1, 5) '%s ' repmat('%f ', 1, 6)],...
    'HeaderLines', 1, 'CollectOutput', true);
fclose(fid);
rawdata = [rawdata{1,1} cellfun(@(s) strcmp(s,'Present'),rawdata{1, 2}), ...
    rawdata{1, 3}];

% sbp, tobacco, ldl, famhist, obesity, alcohol, age
X = rawdata(:,[2 3 4 6 8 9 10]);
X = bsxfun(@minus, X, mean(X, 1));   % centering
X = bsxfun(@rdivide, X, std(X));    % standardize
X = [ones(size(X,1), 1), X];
y = rawdata(:, end - 1);
trainidx = logical(rawdata(:, end));

% train/test split
Xtr = X(trainidx, :);
ytr = y(trainidx);
Xte = X(~trainidx, :);
yte = y(~trainidx);

% fit logistic reg. and make sure the results match that in ESLII p126 Fig 4.13
b0 = glmfit(Xtr, ytr, 'binomial','constant','off');
display(b0);

% change 0/1-valued y to -1/1-valued class labels
ctr = 2 * ytr - 1;
cte = 2 * yte - 1;

%%
% Solve 1-norm svm over a grid
lambdalist = 0:0.1:2.5;
bhat_path = zeros(size(Xtr, 2), length(lambdalist));
err_path = zeros(1, length(lambdalist));
tic;
for i = 1:length(lambdalist)
  lambda = lambdalist(i);
  bhat_path(:, i) = svml1(Xtr, ctr, lambda);
  err_path(i) = nnz(cte ~= sign(Xte * bhat_path(:, i))) / length(cte);
end
toc;

% plot solution path
figure;
set(gca, 'FontSize', 15);
plot(lambdalist, bhat_path(2:end, :));
xlabel('\lambda');
title('1-norm SVM');
predname = {'sbp', 'tobacco', 'ldl', 'famhist', 'obesity', 'alcohol', 'age'};
for i = 1:length(predname)
  text(lambdalist(end)+0.03, bhat_path(i + 1, end), predname{i}, ...
    'HorizontalAlignment','left');
end

% plot testing error
figure;
set(gca, 'FontSize', 15);
plot(lambdalist, err_path);
xlabel('\lambda');
ylabel('misclassification rate');
title('1-norm SVM');

%%
% This is my function for fitting 1-norm svm
type svml1
##### SOURCE END #####
--></body></html>